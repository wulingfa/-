##### 重要：什么是拷贝？

直观的感受什么是拷贝。

let arr = [1,2,3];

let newArr = arr;

newArr[0] = 100;

console.log(arr);//[100, 2, 3]

这是直接赋值的情况，不涉及任何拷贝。当改变newArr的时候，由于是同一个引用，arr指向的值也跟着改变。

现在进行浅拷贝：

let arr = [1,2,3];

let newArr = arr.slice();

newArr[0] = 100;

console.log(arr);//[1,2,3]

当修改newArr的时候，arr的值并不改变。什么原因？因为这里的newArr是arr浅拷贝后的结果，newArr和arr现在引用的已经不是同一块空间了

但是这又会带来一个潜在的问题：

let arr = [1,2,{val:4}];

let newArr = arr.slice();

newArr[2].val = 1000;

console.log(arr);//[1,2,{ val:1000 }]

不是已经不是同一块空间的引用了吗？为什么改变了newArr改变了第二个元素的val值，arr也跟着变了；

这就是浅拷贝的限制所在了。他只能拷贝一层对象；如果有对象的嵌套，那么浅拷贝将无能为力。但幸运的是，深拷贝就是为了解决这个问题而生的，他能解决无限极的对象嵌套问题，实现彻底的拷贝。

JS中实现深拷贝的几种方式；

##### 1.手动实现

const shallowClone = (target) => {

​       if(typeof target === 'object' && target  !== null)  {

​       const cloneTarget = Array.isArray(target) ? []: {};

​       for(let prop in target) {

​          if( target.hasOwnProperty(prop) ) {

​              cloneTarget[prop] = target[prop];

​          }

​    }

​    return cloneTarget;

} else {

​    return target;

​    }         

}

2.Object.assign

但是需要注意的是，Object.assign()拷贝的是对象的属性的引用，而不是对象本身；

let obj = { name: 'sy', age:18 };

const obj2 = Object.assign({},obj,{name:'sss'});

console.log(obj2);//{ name: 'sss',age: 18 }

3.concat浅拷贝数组

let arr = [1,2,3];

let newArr = arr.concat();

newArr[1] = 100;

console.log(arr);//[ 1,2,3 ]

4.slice浅拷贝

let arr = [1,2,3];

let newArr = arr.slice();

newArr[0] = 100;

console.log(arr);//[1,2,3]

5.  ...展开运算符

   let arr = [1,2,3];

   let newArr = [...arr];//和arr.slice()是一样的效果